
<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Nh·∫≠p Danh M·ª•c H√†ng H√≥a</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #999; padding: 5px; text-align: left; }
    input, button { margin: 5px 0; }
  </style>
</head>
<body>

<h2>üì¶ C·∫≠p nh·∫≠t Danh M·ª•c H√†ng H√≥a t·ª´ Excel/CSV</h2>

<input type="file" id="fileInput" accept=".csv,.xlsx" />
<button onclick="loadCSV()">ƒê·ªçc d·ªØ li·ªáu</button>
<div id="preview"></div>
<button onclick="uploadToSupabase()">üì§ Ghi v√†o Supabase</button>

<script>
  const SUPABASE_URL = 'https://rddjrmbyftlcvrgzlyby.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkZGpybWJ5ZnRsY3ZyZ3pseWJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY3NjU4MDQsImV4cCI6MjA2MjM0MTgwNH0.-0xtqxn6b9OBz4unTTvJ4klxizWhHa1iSuYGm7cOYTM';
  const TABLE_NAME = 'dmhanghoa';

  let parsedData = [];

  function loadCSV() {
    const file = document.getElementById('fileInput').files[0];
    if (!file) return alert('Vui l√≤ng ch·ªçn file CSV.');

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: function (results) {
        parsedData = results.data;
        renderPreview(parsedData);
        console.log("üß™ D√≤ng ƒë·∫ßu:", parsedData[0]);
      }
    });
  }

  function renderPreview(data) {
    const preview = document.getElementById("preview");
    if (data.length === 0) return preview.innerHTML = "Kh√¥ng c√≥ d·ªØ li·ªáu.";

    const keys = Object.keys(data[0]);
    let html = "<table><thead><tr>";
    keys.forEach(k => html += `<th>${k}</th>`);
    html += "</tr></thead><tbody>";

    data.slice(0, 10).forEach(row => {
      html += "<tr>";
      keys.forEach(k => html += `<td>${row[k]}</td>`);
      html += "</tr>";
    });

    html += "</tbody></table>";
    preview.innerHTML = html;
  }

  function isValidDate(d) {
    return !isNaN(Date.parse(d));
  }

  function cleanRow(row) {
    const validFields = {
      masp: "text",
      tensp: "text",
      dvt: "text",
      chungloai: "text",
      giale: "numeric",
      giasi: "numeric",
      mangan: "text",
      nhomhang: "text",
      mausac: "text",
      gianhap: "numeric",
      nhacc: "text",
      quanlykichco: "boolean",
      nhapdau: "date",
      ngaysua: "date"
    };

    const cleaned = {};
    for (const key in validFields) {
      if (!(key in row)) continue;
      const val = row[key];

      if (val === "") {
        cleaned[key] = null;
      } else if (validFields[key] === "numeric") {
        cleaned[key] = isNaN(Number(val)) ? null : Number(val);
      } else if (validFields[key] === "boolean") {
        cleaned[key] = val.toLowerCase() === "true" || val === "1";
      } else if (validFields[key] === "date") {
        cleaned[key] = isValidDate(val) ? val : null;
      } else {
        cleaned[key] = val;
      }
    }

    return cleaned;
  }

  async function uploadToSupabase() {
    if (parsedData.length === 0) return alert("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ ghi.");
    const yes = confirm("B·∫°n c√≥ ch·∫Øc mu·ªën ghi d·ªØ li·ªáu n√†y v√†o Supabase? (S·∫Ω ghi ƒë√® n·∫øu m√£ s·∫£n ph·∫©m tr√πng)");
    if (!yes) return;

    const batchSize = 1000;
    let countInsert = 0;
    let countUpdate = 0;
    let countError = 0;
    let errorList = [];

    for (let i = 0; i < parsedData.length; i += batchSize) {
      const batch = parsedData.slice(i, i + batchSize)
        .filter(row => row.masp && row.masp.trim() !== "")
        .map(cleanRow);

      try {
        const res = await fetch(`${SUPABASE_URL}/rest/v1/${TABLE_NAME}`, {
          method: "POST",
          headers: {
            apikey: SUPABASE_KEY,
            Authorization: `Bearer ${SUPABASE_KEY}`,
            "Content-Type": "application/json",
            Prefer: "resolution=merge-duplicates,return=representation"
          },
          body: JSON.stringify(batch)
        });

        const data = await res.json();
        if (!res.ok) {
          const errText = JSON.stringify(data);
          countError += batch.length;
          errorList.push(`L·ªói batch t·ª´ d√≤ng ${i + 1} ƒë·∫øn ${i + batch.length}: ${errText}`);
          console.error("L·ªói ghi batch:", errText);
        } else {
          for (const item of data) {
            if (item.updated_at || item.ngaysua) countUpdate++;
            else countInsert++;
          }
        }
      } catch (err) {
        countError += batch.length;
        errorList.push(`L·ªói k·∫øt n·ªëi batch t·ª´ d√≤ng ${i + 1} ƒë·∫øn ${i + batch.length}`);
        console.error("L·ªói exception:", err);
      }
    }

    const tong = parsedData.length;
    const report = `
      <h3>üìä K·∫øt qu·∫£ ghi d·ªØ li·ªáu:</h3>
      <ul>
        <li>‚úÖ T·ªïng: ${tong}</li>
        <li>üÜï Th√™m m·ªõi: ${countInsert}</li>
        <li>‚ôªÔ∏è Ghi ƒë√®: ${countUpdate}</li>
        <li>‚ùå L·ªói: ${countError}</li>
      </ul>
      ${countError > 0 ? `<details><summary>üîç Xem chi ti·∫øt l·ªói</summary><pre>${errorList.join("\n")}</pre></details>` : ""}
    `;
    document.getElementById("preview").innerHTML = report;
  }
</script>

</body>
</html>
